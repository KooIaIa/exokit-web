<!doctype html>
<html>
  <head>
    <script src="three.js"></script>
    <!-- <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script> -->
    <!-- <script src="BufferGeometryUtils.js"></script>
    <script src="GLTFLoader.js"></script>
    <script src="LegacyGLTFLoader.js"></script> -->
  </head>
  <body>
    <script type=module>
(async () => {
try {

console.log('app 1');

let xrIframe = null;

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;

/* const cubeMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.1, 0.1, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0xab47bc,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.position.z = -5;
  mesh.rotation.order = 'YXZ';
  mesh.frustumCulled = false;
  return mesh;
})();
scene.add(cubeMesh); */

const floorMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(300, 300, 300, 300)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
    // .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
  const floorVsh = `
    uniform float uAnimation;
    // attribute float scene;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      float radius = sqrt(position.x*position.x + position.z*position.z);
      // vec3 p = vec3(position.x, position.y - (1.0 - uAnimation * radius), position.z);
      vec3 p = vec3(position.x, position.y - (1.0 - uAnimation) * radius, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position;
      // vScene = scene;
      vDepth = gl_Position.z / 200.0;
    }
  `;
  const floorFsh = `
    uniform float uAnimation;
    // uniform sampler2D uTex;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      vec3 c;
      float a;
      c = vec3(0.8 + vDepth);
      /* vec2 uv = floor(vPosition + 150).xz / 300.0;
      c = texture2D(uTex, uv).rgb; */
      vec3 f = fract(vPosition);
      if (f.x <= 0.01 || f.x >= 0.99 || f.z <= 0.01 || f.z >= 0.99) {
        // a = 0.0;
        discard;
      } else {
        a = uAnimation*0.5;
      }
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      /* uTex: {
        type: 't',
        value: new THREE.Texture(),
      }, */
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
  mesh.intersect = ray => {
    const point = ray.origin.y !== 0 ? ray.intersectPlane(mesh.plane, localVector) : null;
    if (point) {
      const distance = ray.origin.distanceTo(point);
      if (distance < 10) {
        const {x, z: y} = point;
        return {
          type: 'floor',
          mesh,
          point,
          distance,
          cancel: false,
          x,
          y,
        };
      } else {
        return null;
      }
    } else {
      return null;
    }
  };
  return mesh;
})();
scene.add(floorMesh);

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1, 1.5);
camera.lookAt(new THREE.Vector3(0, 0.5, 0));

scene.add(camera);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const layers = [renderer.domElement];

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

// bootstrap

function animate() {
  const rate = 5000;
  const f = (Date.now() % rate) / rate;
  xrIframe.position = [0, Math.sin(f * Math.PI*2) / 2, 0];
  xrIframe.orientation = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, (-1 + Math.sin(f * Math.PI*4) * 2) * 0.1, 'YXZ')).toArray();
  const s = 0.3 + (1 + Math.sin(f * Math.PI*4)) / 2 * 0.7;
  xrIframe.scale = [s, s, s];

  renderer.render(scene, camera);
}
const _startFakeVrDisplay = async (width, height) => {
  const fakeXrDisplay = new FakeXRDisplay();
  if (isFinite(width)) {
    fakeXrDisplay.width = width;
  }
  if (isFinite(height)) {
    fakeXrDisplay.height = height;
  }
  fakeXrDisplay.position.copy(camera.position);
  fakeXrDisplay.quaternion.copy(camera.quaternion);
  fakeXrDisplay.pushUpdate();
  fakeXrDisplay.enable();
  await _enterXr();
  
  renderer.setAnimationLoop(animate);
};
const _enterXr = async () => {
  const session = await navigator.xr.requestSession({
    exclusive: true,
  });
  session.layers = layers;

  session.requestAnimationFrame((timestamp, frame) => {
    renderer.vr.setSession(session, {
      frameOfReferenceType: 'stage',
    });

    const pose = frame.getViewerPose();
    const viewport = session.baseLayer.getViewport(pose.views[0]);
    // const width = viewport.width;
    const height = viewport.height;
    const fullWidth = (() => {
      let result = 0;
      for (let i = 0; i < pose.views.length; i++) {
        result += session.baseLayer.getViewport(pose.views[i]).width;
      }
      return result;
    })();
    renderer.setSize(fullWidth, height);
    renderer.setPixelRatio(1);

    renderer.setAnimationLoop(null);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);
    renderer.vr.setAnimationLoop(animate);

    console.log('loaded root in XR');
  });
};
_startFakeVrDisplay()
  .then(() => {
    xrIframe = document.createElement('xr-iframe');
    xrIframe.src = 'examples/tutorial.html';
    layers.push(xrIframe);

    console.log('loaded fake display');
  })
  .catch(err => {
    console.warn(err.stack);
  });

console.log('app 2');

} catch(err) {
  console.warn(err);
}
})();
    </script>
  </body>
</html>
