<!doctype html>
<html>
<head>
  <script src="three.js"></script>
  <script src="OrbitControls.js"></script>
  <script src="TransformControls.js"></script>
</head>
<body>
<xr-site>
  <xr-iframe src="examples/floor.html" name="Floor"></xr-iframe>
</xr-site>
<script>
(async () => {
try {

console.log('app 1');

const root = document.querySelector('xr-site');
const floorXrIframe = document.querySelector('xr-iframe');
new MutationObserver(async mutations => {
  for (let i = 0; i < mutations.length; i++) {
    const {addedNodes, removedNodes} = mutations[i];

    for (let j = 0; j < removedNodes.length; j++) {
      const removedNode = removedNodes[j];

      if (removedNode instanceof XRIFrame) {
        const xrIframe = removedNode;

        scene.remove(xrIframe.control);
      }
    }
    for (let j = 0; j < addedNodes.length; j++) {
      const addedNode = addedNodes[j];

      if (addedNode instanceof XRIFrame) {
        const xrIframe = addedNode;

        const object = new THREE.Object3D();
        object.position.fromArray(xrIframe.position);
        scene.add(object);

        const control = new THREE.TransformControls(vrCamera, renderer.domElement);
        control.attach(object);
        control.size = 3;
        control.addEventListener('change', e => {
          xrIframe.position = object.position.toArray();
          xrIframe.quaternion = object.quaternion.toArray();
          xrIframe.scale = object.scale.toArray();
        });
        control.addEventListener('dragging-changed', e => {
          orbitControls.enabled = !e.value;
        });
        xrIframe.control = control;
        scene.add(control);
      }
    }
  }
}).observe(root, {
  childList: true,
});

const vrCamera = new THREE.PerspectiveCamera();
vrCamera.updateMatrixWorld = () => {};
let orbitControls = null;
let fakeXrDisplay;

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 3);
camera.lookAt(new THREE.Vector3(0, 0.5, 0));

scene.add(camera);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

root.addLayer(renderer.domElement);

function animate() {
  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      if (root.fakeXrDisplay) {
        root.fakeXrDisplay.position.copy(orbitControls.object.position);
        root.fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);

        root.fakeXrDisplay.pushUpdate();
      }
    }
  };
  _updateOrbitControls();

  const _updateVrCamera = () => {
    vrCamera.matrixWorldInverse.fromArray(root.fakeXrDisplay.viewMatrix);
    vrCamera.matrixWorld.getInverse(vrCamera.matrixWorldInverse);
    vrCamera.projectionMatrix.fromArray(root.fakeXrDisplay.projectionMatrix);
    vrCamera.projectionMatrixInverse.getInverse(vrCamera.projectionMatrix);
  };
  _updateVrCamera();

  renderer.render(scene, camera);
}

const session = await root.requestSession();

renderer.vr.setSession(session, {
  frameOfReferenceType: 'stage',
});
console.log('set size', root.width, root.height);
renderer.setSize(root.width, root.height);
renderer.setPixelRatio(1);

renderer.setAnimationLoop(null);

renderer.vr.enabled = true;
// renderer.vr.setSession(session);
renderer.vr.setAnimationLoop(animate);

root.fakeXrDisplay.position.copy(camera.position);
root.fakeXrDisplay.quaternion.copy(camera.quaternion);
root.fakeXrDisplay.pushUpdate();

const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
orbitCamera.position.copy(root.fakeXrDisplay.position);
orbitCamera.quaternion.copy(root.fakeXrDisplay.quaternion);
orbitControls.screenSpacePanning = true;
orbitControls.enableKeys = false;
orbitControls.update();

// Listen to messages from parent window
window.addEventListener('message', e => {
  const {data} = e;
  const {method} = data;
  switch (method) {
    case 'load': {
      const xrIframe = document.createElement('xr-iframe');
      xrIframe.src = data.url;
      xrIframe.name = data.name;
      xrIframe.position = data.origin ? [
        0,
        0.5,
        0,
      ] : [
        -1 + Math.random() * 2,
        0.1,
        -1 + Math.random() * 2,
      ];
      const xrIframes = Array.from(root.childNodes).filter(childNode => childNode instanceof XRIFrame);
      if (xrIframes.length > 0 && xrIframes[xrIframes.length - 1] === floorXrIframe) {
        root.insertBefore(xrIframe, floorXrIframe);
        root.insertBefore(new Text('\n  '), floorXrIframe);
      } else {
        root.appendChild(new Text('\n  '));
        root.appendChild(xrIframe);
        if (root.lastChild.nodeType !== Node.TEXT_NODE) {
          root.appendChild(new Text('\n'));
        }
      }

      break;
    }
    case 'unload': {
      const {index} = data;
      const xrIframe = Array.from(root.childNodes).filter(childNode => childNode instanceof XRIFrame)[index];
      if (xrIframe.previousSibling && xrIframe.previousSibling.nodeType === Node.TEXT_NODE) {
        xrIframe.parentNode.removeChild(xrIframe.previousSibling);
      }
      xrIframe.parentNode.removeChild(xrIframe);

      break;
    }
    case 'getCode': {
      window.parentPostMessage({
        method: 'code',
        code: root.outerHTML.replace(
          '<xr-iframe src="examples/floor.html" name="Floor"></xr-iframe>',
          `<xr-iframe src="${window.location.origin}/examples/floor.html" name="Floor"></xr-iframe>`
        ),
      });
      break;
    }
    case 'setCode': {
      const {code} = data;
      const match = code.match(/^\s*<xr-site>([\s\S]*)<\/xr-site>\s*$/mi);
      if (match) {
        root.innerHTML = match[1];
      }
      window.parentPostMessage({
        method: 'tabs',
        tabs: Array.from(root.childNodes)
          .filter(childNode => childNode instanceof XRIFrame)
          .map(childNode => childNode.name),
      });
      break;
    }
  }
});

console.log('app 2');

} catch(err) {
  console.warn(err);
}
})();
</script>
</body>
</html>
