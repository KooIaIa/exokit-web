<!doctype html>
<html>
  <head>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script>
  </head>
  <body>
    <script type=module>
(async () => {
try {

console.log('app 1');

const vrCamera = new THREE.PerspectiveCamera();
vrCamera.updateMatrixWorld = () => {};
let orbitControls = null;
// let tutorialXrIframe = null;
let fakeXrDisplay;

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 3);
camera.lookAt(new THREE.Vector3(0, 0.5, 0));

scene.add(camera);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const layers = [renderer.domElement];

function animate() {
  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      if (fakeXrDisplay) {
        fakeXrDisplay.position.copy(orbitControls.object.position);
        fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);

        fakeXrDisplay.pushUpdate();
      }
    }
  };
  _updateOrbitControls();

  const _updateVrCamera = () => {
    vrCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
    vrCamera.matrixWorld.getInverse(vrCamera.matrixWorldInverse);
    vrCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
    vrCamera.projectionMatrixInverse.getInverse(vrCamera.projectionMatrix);
  };
  _updateVrCamera();

  renderer.render(scene, camera);
}
const _startFakeVrDisplay = async () => {
  fakeXrDisplay = new FakeXRDisplay();
  fakeXrDisplay.position.copy(camera.position);
  fakeXrDisplay.quaternion.copy(camera.quaternion);
  fakeXrDisplay.pushUpdate();
  fakeXrDisplay.enable();
  await _enterXr();

  // renderer.setAnimationLoop(animate);
};
const _enterXr = async () => {
  const session = await navigator.xr.requestSession({
    exclusive: true,
  });
  session.layers = layers;

  session.requestAnimationFrame((timestamp, frame) => {
    renderer.vr.setSession(session, {
      frameOfReferenceType: 'stage',
    });

    const pose = frame.getViewerPose();
    const viewport = session.baseLayer.getViewport(pose.views[0]);
    // const width = viewport.width;
    const height = viewport.height;
    const fullWidth = (() => {
      let result = 0;
      for (let i = 0; i < pose.views.length; i++) {
        result += session.baseLayer.getViewport(pose.views[i]).width;
      }
      return result;
    })();
    renderer.setSize(fullWidth, height);
    renderer.setPixelRatio(1);

    renderer.setAnimationLoop(null);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);
    renderer.vr.setAnimationLoop(animate);

    const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
    orbitCamera.position.copy(fakeXrDisplay.position);
    orbitCamera.quaternion.copy(fakeXrDisplay.quaternion);
    /* scene.add(orbitCamera);
    orbitCamera.updateMatrixWorld();
    orbitControls.target.copy(orbitCamera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(orbitCamera.quaternion)); */
    orbitControls.screenSpacePanning = true;
    orbitControls.update();

    console.log('loaded root in XR');
  });
};
_startFakeVrDisplay()
  .then(() => {
    const xrIframe = document.createElement('xr-iframe');
    xrIframe.src = 'examples/floor.html';
    layers.push(xrIframe);

    // Listen to messages from parent window
    window.addEventListener('message', e => {
      const {data} = e;
      const {method} = data;
      switch (method) {
        case 'load': {
          const xrIframe = document.createElement('xr-iframe');
          xrIframe.src = data.url;
          xrIframe.position = data.origin ? [
            0,
            0.1,
            0,
          ] : [
            -1 + Math.random() * 2,
            0.25,
            -1 + Math.random() * 2,
          ];
          layers.push(xrIframe);

          const object = new THREE.Object3D();
          object.position.fromArray(xrIframe.position);
          scene.add(object);

          const control = new THREE.TransformControls(vrCamera, renderer.domElement);
          control.attach(object);
          control.size = 3;
          control.addEventListener('change', e => {
            xrIframe.position = object.position.toArray();
            xrIframe.quaternion = object.quaternion.toArray();
            xrIframe.scale = object.scale.toArray();
          });
          control.addEventListener('dragging-changed', e => {
            orbitControls.enabled = !e.value;
          });
          xrIframe.control = control;
          scene.add(control);

          break;
        }
        case 'unload': {
          const {index} = data;
          const xrIframe = layers.splice(1 + index, 1)[0];
          scene.remove(xrIframe.control);
          xrIframe.destroy();

          break;
        }
      }
    });

    console.log('loaded fake display');
  })
  .catch(err => {
    console.warn(err.stack);
  });

console.log('app 2');

} catch(err) {
  console.warn(err);
}
})();
    </script>
  </body>
</html>
