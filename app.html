<!doctype html>
<html>
  <head>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="TransformControls.js"></script>
  </head>
  <body>
    <script type=module>
(async () => {
try {

console.log('app 1');

const vrCamera = new THREE.PerspectiveCamera();
vrCamera.updateMatrixWorld = () => {};
let orbitControls = null;
// let tutorialXrIframe = null;
let fakeXrDisplay;

// main

const scene = new THREE.Scene();
// scene.fog = new THREE.Fog(new THREE.Color(0x7e57c2).offsetHSL(0, 0, -0.45), 1, 100);
// scene.background = new THREE.Color(0xFFFFFF);
scene.matrixAutoUpdate = false;


const floorMesh = (() => {
  const geometry = new THREE.PlaneBufferGeometry(300, 300, 300, 300)
    .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
    // .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0, -0.5));
  const floorVsh = `
    uniform float uAnimation;
    // attribute float scene;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      float radius = sqrt(position.x*position.x + position.z*position.z);
      // vec3 p = vec3(position.x, position.y - (1.0 - uAnimation * radius), position.z);
      vec3 p = vec3(position.x, position.y - (1.0 - uAnimation) * radius, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position;
      // vScene = scene;
      vDepth = gl_Position.z / 200.0;
    }
  `;
  const floorFsh = `
    uniform float uAnimation;
    // uniform sampler2D uTex;
    varying vec3 vPosition;
    // varying float vScene;
    varying float vDepth;
    void main() {
      vec3 c;
      float a;
      c = vec3(min(0.8 + vDepth, 0.9725490196078431)); // 0xf8/0xff
      /* vec2 uv = floor(vPosition + 150).xz / 300.0;
      c = texture2D(uTex, uv).rgb; */
      vec3 f = fract(vPosition);
      if (f.x <= 0.01 || f.x >= 0.99 || f.z <= 0.01 || f.z >= 0.99) {
        // a = 0.0;
        discard;
      } else {
        a = uAnimation*0.5;
      }
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      /* uTex: {
        type: 't',
        value: new THREE.Texture(),
      }, */
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3());
  mesh.intersect = ray => {
    const point = ray.origin.y !== 0 ? ray.intersectPlane(mesh.plane, localVector) : null;
    if (point) {
      const distance = ray.origin.distanceTo(point);
      if (distance < 10) {
        const {x, z: y} = point;
        return {
          type: 'floor',
          mesh,
          point,
          distance,
          cancel: false,
          x,
          y,
        };
      } else {
        return null;
      }
    } else {
      return null;
    }
  };
  return mesh;
})();
scene.add(floorMesh);

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 3);
camera.lookAt(new THREE.Vector3(0, 0.5, 0));

scene.add(camera);

const renderer = new THREE.WebGLRenderer({
  antialias: true,
});
console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
document.body.appendChild(renderer.domElement);

const layers = [renderer.domElement];

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight.position.set(1, 1, 1);
scene.add(directionalLight);

function animate() {
  const _updateOrbitControls = () => {
    if (orbitControls) {
      orbitControls.update();

      if (fakeXrDisplay) {
        fakeXrDisplay.position.copy(orbitControls.object.position);
        fakeXrDisplay.quaternion.copy(orbitControls.object.quaternion);

        fakeXrDisplay.pushUpdate();
      }
    }
  };
  _updateOrbitControls();

  const _updateVrCamera = () => {
    vrCamera.matrixWorldInverse.fromArray(fakeXrDisplay.viewMatrix);
    vrCamera.matrixWorld.getInverse(vrCamera.matrixWorldInverse);
    vrCamera.projectionMatrix.fromArray(fakeXrDisplay.projectionMatrix);
    vrCamera.projectionMatrixInverse.getInverse(vrCamera.projectionMatrix);
  };
  _updateVrCamera();

  /* const rate = 5000;
  const f = (Date.now() % rate) / rate;
  tutorialXrIframe.position = [0, Math.sin(f * Math.PI*2) / 2, 0];
  tutorialXrIframe.orientation = new THREE.Quaternion().setFromEuler(new THREE.Euler(0, 0, (-1 + Math.sin(f * Math.PI*4) * 2) * 0.1, 'YXZ')).toArray();
  const s = 0.3 + (1 + Math.sin(f * Math.PI*4)) / 2 * 0.7;
  tutorialXrIframe.scale = [s, s, s]; */

  renderer.render(scene, camera);
}
const _startFakeVrDisplay = async () => {
  fakeXrDisplay = new FakeXRDisplay();
  fakeXrDisplay.position.copy(camera.position);
  fakeXrDisplay.quaternion.copy(camera.quaternion);
  fakeXrDisplay.pushUpdate();
  fakeXrDisplay.enable();
  await _enterXr();

  // renderer.setAnimationLoop(animate);
};
const _enterXr = async () => {
  const session = await navigator.xr.requestSession({
    exclusive: true,
  });
  session.layers = layers;

  session.requestAnimationFrame((timestamp, frame) => {
    renderer.vr.setSession(session, {
      frameOfReferenceType: 'stage',
    });

    const pose = frame.getViewerPose();
    const viewport = session.baseLayer.getViewport(pose.views[0]);
    // const width = viewport.width;
    const height = viewport.height;
    const fullWidth = (() => {
      let result = 0;
      for (let i = 0; i < pose.views.length; i++) {
        result += session.baseLayer.getViewport(pose.views[i]).width;
      }
      return result;
    })();
    renderer.setSize(fullWidth, height);
    renderer.setPixelRatio(1);

    renderer.setAnimationLoop(null);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);
    renderer.vr.setAnimationLoop(animate);

    const orbitCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
    orbitCamera.position.copy(fakeXrDisplay.position);
    orbitCamera.quaternion.copy(fakeXrDisplay.quaternion);
    /* scene.add(orbitCamera);
    orbitCamera.updateMatrixWorld();
    orbitControls.target.copy(orbitCamera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(orbitCamera.quaternion)); */
    orbitControls.screenSpacePanning = true;
    orbitControls.update();

    console.log('loaded root in XR');
  });
};
_startFakeVrDisplay()
  .then(() => {

    /* tutorialXrIframe = document.createElement('xr-iframe');
    tutorialXrIframe.src = 'examples/tutorial.html';
    layers.push(tutorialXrIframe); */

    // Listen to messages from parent window
    window.addEventListener('message', e => {
      const {data} = e;
      const {method} = data;
      switch (method) {
        case 'load': {
          const xrIframe = document.createElement('xr-iframe');
          xrIframe.src = data.url;
          xrIframe.position = data.origin ? [
            0,
            0.1,
            0,
          ] : [
            -1 + Math.random() * 2,
            0.25,
            -1 + Math.random() * 2,
          ];
          layers.push(xrIframe);

          const object = new THREE.Object3D();
          object.position.fromArray(xrIframe.position);
          scene.add(object);

          const control = new THREE.TransformControls(vrCamera, renderer.domElement);
          control.attach(object);
          control.size = 3;
          control.addEventListener('change', e => {
            xrIframe.position = object.position.toArray();
            xrIframe.quaternion = object.quaternion.toArray();
            xrIframe.scale = object.scale.toArray();
          });
          control.addEventListener('dragging-changed', e => {
            orbitControls.enabled = !e.value;
          });
          xrIframe.control = control;
          scene.add(control);

          break;
        }
        case 'unload': {
          const {index} = data;
          const xrIframe = layers.splice(1 + index, 1)[0];
          scene.remove(xrIframe.control);
          xrIframe.destroy();

          break;
        }
      }
    });

    console.log('loaded fake display');
  })
  .catch(err => {
    console.warn(err.stack);
  });

console.log('app 2');

} catch(err) {
  console.warn(err);
}
})();
    </script>
  </body>
</html>
