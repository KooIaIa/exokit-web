<!doctype html>
<html>
  <head>
    <meta http-equiv="origin-trial" content="AsQEDTijFlTxO2I52106H67AARzxf+HYsBUi4M0oZ4NMeVaX0tpAYmChNT1xvqRUsd6YtnMM3twvKXWbE6CmhwUAAABseyJvcmlnaW4iOiJodHRwczovL3dlYi53ZWJhdmVyc2UuY29tOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU03NiIsImV4cGlyeSI6MTU2ODc2NTgzMiwiaXNTdWJkb21haW4iOnRydWV9">
    <!-- <meta http-equiv="origin-trial" content="AoprcL54oQGdbB0YIadZOZ6yiv8vwl/7Va72+lm6Mr7jo6bGQZZ7QKpiap9QkdeultpOPUilQN7aviUdvz1mZwIAAABoeyJvcmlnaW4iOiJodHRwczovL3dlYmF2ZXJzZS5jb206NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTY4NzYxNzMxLCJpc1N1YmRvbWFpbiI6dHJ1ZX0="> -->
    <style>
body {
  margin: 0;
}
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <canvas id="canvas2"></canvas>
    <canvas id="canvas3"></canvas>
    <script src="three.js"></script>
    <script>
(async () => {
let t, screenQuadVBO, shaderProgram, imageBitmap = null;

const worker = new Worker('iframe-worker.js');
// console.log('start', worker);
const canvas = document.getElementById('canvas');
const canvas2 = document.getElementById('canvas2');
const canvas3 = document.getElementById('canvas3');

/* const renderer = new THREE.WebGLRenderer({
  canvas: canvas3,
  antialias: true,
  // alpha: true,
});
const context = renderer.getContext();
renderer.setPixelRatio(window.devicePixelRatio);
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(); */
const offscreenCanvas = canvas.transferControlToOffscreen();
const imageBitmapRenderingContext = canvas2.getContext('bitmaprenderer');
const context = canvas3.getContext('webgl');

// const lockBuffer = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));
// const lockBuffer2 = new Int32Array(new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT));
worker.postMessage({
  canvas: offscreenCanvas,
  /* lockBuffer,
  lockBuffer2, */
}, [offscreenCanvas]);

const _onmessage = () => {
worker.removeEventListener('message', _onmessage);
worker.addEventListener('message', _onmessage2);

function animate() {
  worker.postMessage({
    modelViewMatrices: [],
    projectionMatrices: [],
  });

  // Only created once
  if (!t) {
    t = context.createTexture();
    context.bindTexture(context.TEXTURE_2D, t);
    context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE, null);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);

    var verts = [
      // First triangle:
       1.0,  1.0,
      -1.0,  1.0,
      -1.0, -1.0,
      // Second triangle:
      -1.0, -1.0,
       1.0, -1.0,
       1.0,  1.0
    ];
    screenQuadVBO = context.createBuffer();
    context.bindBuffer(context.ARRAY_BUFFER, screenQuadVBO);
    context.bufferData(context.ARRAY_BUFFER, new Float32Array(verts), context.STATIC_DRAW);

    shaderProgram = context.createProgram();

    {
      const vsh = `
        attribute vec2 position;
        varying vec2 vTexCoords;
        const vec2 scale = vec2(0.5, 0.5);
        void main() {
          vTexCoords  = position * scale + scale; // scale vertex attribute to [0,1] range
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;
      const shader = context.createShader(context.VERTEX_SHADER);
      context.shaderSource(shader, vsh);
      context.compileShader(shader);
      if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
        console.log(`Error compiling vertex shader:`);
        console.log(context.getShaderInfoLog(shader));
      }
      context.attachShader(shaderProgram, shader);
    }
    {
      const fsh = `
        precision highp float;
        uniform sampler2D uTex;
        varying vec2 vTexCoords;
        void main() {
          gl_FragColor = texture2D(uTex, vTexCoords);
        }
      `;
      const shader = context.createShader(context.FRAGMENT_SHADER);
      context.shaderSource(shader, fsh);
      context.compileShader(shader);
      if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
        console.log(`Error compiling fragment shader:`);
        console.log(context.getShaderInfoLog(shader));
      }
      context.attachShader(shaderProgram, shader);
    }

    context.linkProgram(shaderProgram)
    if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
      console.log("Error linking shader program:");
      console.log(context.getProgramInfoLog(shaderProgram));
    }
    context.useProgram(shaderProgram);

    const positionLocation = context.getAttribLocation(shaderProgram, 'position');
    context.enableVertexAttribArray(positionLocation);
    context.vertexAttribPointer(positionLocation, 2, context.FLOAT, false, 0, 0);

    const uTexLocation = context.getUniformLocation(shaderProgram, 'uTex');
    context.uniform1i(uTexLocation, 0);
  }

  // console.log('tex 2d 1');
  // context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, canvas2);
  if (imageBitmap) {
    // console.log('2d', context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, imageBitmap);
    context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, imageBitmap);
  }
  // console.log('tex 2d 2');
  context.drawArrays(context.TRIANGLES, 0, 6);
  // context.flush();
}

function raf() {
  requestAnimationFrame(raf);
  animate();
}
requestAnimationFrame(raf);

};
worker.addEventListener('message', _onmessage);
const _onmessage2 = m => {
  if (imageBitmap) {
    imageBitmap.close();
  }
  imageBitmap = m.data.imageBitmap;
  /* if (imageBitmap) {
    imageBitmapRenderingContext.transferFromImageBitmap(imageBitmap);
  } */
};

/* const _enterXr = () => navigator.xr.requestSession('immersive-vr')
  .then(session => {
    console.log('got session', session);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);

    function animate() {
      const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
      renderer.render(scene, c);
    }
    renderer.setAnimationLoop(animate);
  })
  .catch(err => {
    console.warn(err);
  });
await _enterXr();
canvas.addEventListener('click', _enterXr); */

})();
    </script>
  </body>
</html>
