<!doctype html>
<html>
  <head>
    <meta http-equiv="origin-trial" content="AqaFnOTvLgv53D1MfBnxryBskqSxVEAKdX7RXdtHcQbpTu/+K7gOpoasuvbvhT+dvOQoC1vI+KEGLL4jPxWBdQAAAABleyJvcmlnaW4iOiJodHRwczovL2V4b2tpdC5vcmc6NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTY4ODQzNzAwLCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
    <!-- <meta http-equiv="origin-trial" content="AsQEDTijFlTxO2I52106H67AARzxf+HYsBUi4M0oZ4NMeVaX0tpAYmChNT1xvqRUsd6YtnMM3twvKXWbE6CmhwUAAABseyJvcmlnaW4iOiJodHRwczovL3dlYi53ZWJhdmVyc2UuY29tOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU03NiIsImV4cGlyeSI6MTU2ODc2NTgzMiwiaXNTdWJkb21haW4iOnRydWV9"> -->
    <!-- <meta http-equiv="origin-trial" content="AoprcL54oQGdbB0YIadZOZ6yiv8vwl/7Va72+lm6Mr7jo6bGQZZ7QKpiap9QkdeultpOPUilQN7aviUdvz1mZwIAAABoeyJvcmlnaW4iOiJodHRwczovL3dlYmF2ZXJzZS5jb206NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTY4NzYxNzMxLCJpc1N1YmRvbWFpbiI6dHJ1ZX0="> -->
    <style>
body {
  margin: 0;
  display: flex;
  flex-direction: column;
}
    </style>
  </head>
  <body>
    <script src="src/index.js" type="module"></script>
    <!-- <canvas id="canvas"></canvas>
    <canvas id="canvas2"></canvas>
    <canvas id="canvas3"></canvas>
    <script src="three.js"></script>
    <script type="module">
// import exokit from './src/core.js';
import {defaultEyeSeparation, maxNumTrackers} from './src/constants.js';
(async () => {
const options = (() => {
  const options = {};
  options.url = options.url || 'http://127.0.0.1/';
  options.baseUrl = options.baseUrl || options.url;
  // options.dataPath = options.dataPath || __dirname;
  options.args = options.args || {};
  options.htmlString = `<html></html>`;
  // options.replacements = options.replacements || {};
  return options;
})();
const xrState = (() => {
  const _makeSab = size => {
    const sab = new SharedArrayBuffer(size);
    let index = 0;
    return (c, n) => {
      const result = new c(sab, index, n);
      index += result.byteLength;
      return result;
    };
  };
  const _makeTypedArray = _makeSab(32*1024);

  const result = {};
  result.isPresenting = _makeTypedArray(Uint32Array, 1);
  result.renderWidth = _makeTypedArray(Float32Array, 1);
  result.renderWidth[0] = 1920/2;
  result.renderHeight = _makeTypedArray(Float32Array, 1);
  result.renderHeight[0] = 1080;
  result.metrics = _makeTypedArray(Uint32Array, 2);
  result.devicePixelRatio = _makeTypedArray(Uint32Array, 1);
  result.depthNear = _makeTypedArray(Float32Array, 1);
  result.depthNear[0] = 0.1;
  result.depthFar = _makeTypedArray(Float32Array, 1);
  result.depthFar[0] = 10000.0;
  result.position = _makeTypedArray(Float32Array, 3);
  result.orientation = _makeTypedArray(Float32Array, 4);
  result.orientation[3] = 1;
  result.leftViewMatrix = _makeTypedArray(Float32Array, 16);
  result.leftViewMatrix.set(Float32Array.from([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
  result.rightViewMatrix = _makeTypedArray(Float32Array, 16);
  result.rightViewMatrix.set(result.leftViewMatrix);
  result.leftProjectionMatrix = _makeTypedArray(Float32Array, 16);
  result.leftProjectionMatrix.set(Float32Array.from([0.5625000000000001, 0, 0, 0, 0, 1.0000000000000002, 0, 0, 0, 0, -1.0002000200020003, -1, 0, 0, -0.20002000200020004, 0]));
  result.rightProjectionMatrix = _makeTypedArray(Float32Array, 16);
  result.rightProjectionMatrix.set(result.leftProjectionMatrix);
  result.leftOffset = _makeTypedArray(Float32Array, 3);
  result.leftOffset.set(Float32Array.from([-defaultEyeSeparation/2, 0, 0]));
  result.rightOffset = _makeTypedArray(Float32Array, 3);
  result.leftOffset.set(Float32Array.from([defaultEyeSeparation/2, 0, 0]));
  result.leftFov = _makeTypedArray(Float32Array, 4);
  result.leftFov.set(Float32Array.from([45, 45, 45, 45]));
  result.rightFov = _makeTypedArray(Float32Array, 4);
  result.rightFov.set(result.leftFov);
  const _makeGamepad = () => ({
    connected: _makeTypedArray(Uint32Array, 1),
    position: _makeTypedArray(Float32Array, 3),
    orientation: (() => {
      const result = _makeTypedArray(Float32Array, 4);
      result[3] = 1;
      return result;
    })(),
    direction: (() => { // derived
      const result = _makeTypedArray(Float32Array, 4);
      result[2] = -1;
      return result;
    })(),
    transformMatrix: (() => { // derived
      const result = _makeTypedArray(Float32Array, 16);
      result.set(Float32Array.from([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]));
      return result;
    })(),
    buttons: (() => {
      const result = Array(10);
      for (let i = 0; i < result.length; i++) {
        result[i] = {
          pressed: _makeTypedArray(Uint32Array, 1),
          touched: _makeTypedArray(Uint32Array, 1),
          value: _makeTypedArray(Float32Array, 1),
        };
      }
      return result;
    })(),
    axes: _makeTypedArray(Float32Array, 10),
    bones: _makeTypedArray(Float32Array, 31*16),
  });
  result.gamepads = (() => {
    const result = Array(2 + maxNumTrackers);
    for (let i = 0; i < result.length; i++) {
      result[i] = _makeGamepad();
    }
    return result;
  })();
  result.hands = (() => {
    const result = Array(2);
    for (let i = 0; i < result.length; i++) {
      const hand = _makeGamepad();
      hand.wrist = (() => {
        const result = Array(4);
        for (let i = 0; i < result.length; i++) {
          result[i] = _makeTypedArray(Float32Array, 3);
        }
        return result;
      })();
      hand.fingers = (() => {
        const result = Array(5);
        for (let i = 0; i < result.length; i++) {
          result[i] = (() => {
            const result = Array(4);
            for (let i = 0; i < result.length; i++) {
              result[i] = _makeTypedArray(Float32Array, 3);
            }
            return result;
          })();
        }
        return result;
      })();
      result[i] = hand;
    }
    return result;
  })();
  result.eye = _makeGamepad();
  result.id = _makeTypedArray(Uint32Array, 1);
  result.hmdType = _makeTypedArray(Uint32Array, 1);
  result.tex = _makeTypedArray(Uint32Array, 1);
  result.depthTex = _makeTypedArray(Uint32Array, 1);
  result.msTex = _makeTypedArray(Uint32Array, 1);
  result.msDepthTex = _makeTypedArray(Uint32Array, 1);
  result.aaEnabled = _makeTypedArray(Uint32Array, 1);
  result.fakeVrDisplayEnabled = _makeTypedArray(Uint32Array, 1);
  result.meshing = _makeTypedArray(Uint32Array, 1);
  result.planeTracking = _makeTypedArray(Uint32Array, 1);
  result.handTracking = _makeTypedArray(Uint32Array, 1);
  result.eyeTracking = _makeTypedArray(Uint32Array, 1);
  result.blobId = _makeTypedArray(Uint32Array, 1);

  return result;
})();

let t, screenQuadVBO, shaderProgram, imageBitmap = null;

const worker = new Worker('iframe-worker.js', {
  type: 'module',
});
const canvas = document.getElementById('canvas');
const canvas2 = document.getElementById('canvas2');
const canvas3 = document.getElementById('canvas3');

const offscreenCanvas = canvas.transferControlToOffscreen();
const imageBitmapRenderingContext = canvas2.getContext('bitmaprenderer');
const context = canvas3.getContext('webgl');

const _clean = o => {
  const result = {};
  for (const k in o) {
    const v = o[k];
    if (typeof v !== 'function') {
      result[k] = v;
    }
  }
  return result;
};
worker.postMessage({
  canvas: offscreenCanvas,
  args: {
    initModule: './Window.js',
    id: 1,
    args: {},
    version: '0.0.1',
    options: _clean(options),
    xrState,
  },
}, [offscreenCanvas]);

const _onmessage = () => {
worker.removeEventListener('message', _onmessage);
worker.addEventListener('message', _onmessage2);

function animate() {
  worker.postMessage({
    modelViewMatrices: [],
    projectionMatrices: [],
  });

  if (!t) {
    t = context.createTexture();
    context.bindTexture(context.TEXTURE_2D, t);
    context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, 1, 1, 0, context.RGBA, context.UNSIGNED_BYTE, null);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.LINEAR);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.LINEAR);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
    context.texParameteri(context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);

    var VERTS = Float32Array.from([
       1.0,  1.0,
      -1.0,  1.0,
      -1.0, -1.0,
      -1.0, -1.0,
       1.0, -1.0,
       1.0,  1.0,
    ]);
    screenQuadVBO = context.createBuffer();
    context.bindBuffer(context.ARRAY_BUFFER, screenQuadVBO);
    context.bufferData(context.ARRAY_BUFFER, VERTS, context.STATIC_DRAW);

    shaderProgram = context.createProgram();

    {
      const vsh = `
        attribute vec2 position;
        varying vec2 vTexCoords;
        const vec2 scale = vec2(0.5, 0.5);
        void main() {
          vTexCoords  = position * scale + scale; // scale vertex attribute to [0,1] range
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;
      const shader = context.createShader(context.VERTEX_SHADER);
      context.shaderSource(shader, vsh);
      context.compileShader(shader);
      if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
        console.log(`Error compiling vertex shader:`);
        console.log(context.getShaderInfoLog(shader));
      }
      context.attachShader(shaderProgram, shader);
    }
    {
      const fsh = `
        precision highp float;
        uniform sampler2D uTex;
        varying vec2 vTexCoords;
        void main() {
          gl_FragColor = texture2D(uTex, vTexCoords);
        }
      `;
      const shader = context.createShader(context.FRAGMENT_SHADER);
      context.shaderSource(shader, fsh);
      context.compileShader(shader);
      if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
        console.log('Error compiling fragment shader:');
        console.log(context.getShaderInfoLog(shader));
      }
      context.attachShader(shaderProgram, shader);
    }

    context.linkProgram(shaderProgram)
    if (!context.getProgramParameter(shaderProgram, context.LINK_STATUS)) {
      console.log('Error linking shader program:');
      console.log(context.getProgramInfoLog(shaderProgram));
    }
    context.useProgram(shaderProgram);

    const positionLocation = context.getAttribLocation(shaderProgram, 'position');
    context.enableVertexAttribArray(positionLocation);
    context.vertexAttribPointer(positionLocation, 2, context.FLOAT, false, 0, 0);

    const uTexLocation = context.getUniformLocation(shaderProgram, 'uTex');
    context.uniform1i(uTexLocation, 0);
  }

  // context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, canvas2);
  if (imageBitmap) {
    context.texImage2D(context.TEXTURE_2D, 0, context.RGBA, context.RGBA, context.UNSIGNED_BYTE, imageBitmap);
  }
  context.drawArrays(context.TRIANGLES, 0, 6);
  // context.flush();
}

function raf() {
  requestAnimationFrame(raf);
  animate();
}
requestAnimationFrame(raf);

};
worker.addEventListener('message', _onmessage);
const _onmessage2 = m => {
  if (imageBitmap) {
    imageBitmap.close();
  }
  imageBitmap = m.data.imageBitmap;
};

const _enterXr = () => navigator.xr.requestSession('immersive-vr')
  .then(session => {
    console.log('got session', session);

    renderer.vr.enabled = true;
    renderer.vr.setSession(session);

    function animate() {
      const c = renderer.vr.enabled ? renderer.vr.getCamera(camera) : camera;
      renderer.render(scene, c);
    }
    renderer.setAnimationLoop(animate);
  })
  .catch(err => {
    console.warn(err);
  });
canvas.addEventListener('click', _enterXr);
// await _enterXr();

})();
    </script> -->
  </body>
</html>
